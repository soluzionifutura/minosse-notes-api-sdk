/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable no-trailing-spaces */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable quote-props */
/* eslint-disable @typescript-eslint/member-delimiter-style */
/**
 * This file was automatically generated by sf-ts-sdk-gen.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source
 * openapi definition and regenerate this file.
 */

import type { AxiosStatic, AxiosInstance, AxiosResponse, AxiosRequestConfig, AxiosError } from "axios"

import deepmerge from "deepmerge"

function _isObject(o: any): boolean {
  return Object.prototype.toString.call(o) === "[object Object]"
}

export function isPlainObject(o: any): boolean {
  if (_isObject(o) === false) {
    return false
  }

  const ctor = o.constructor
  if (ctor === undefined) {
    return true
  }

  const prot = ctor.prototype
  if (_isObject(prot) === false) {
    return false
  }

  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false
  }

  return true
}

export const SDK_VERSION = "0.1.0"

export const API_VERSION = "1.0.0"

export let axios: AxiosStatic | AxiosInstance | undefined

export type Env = "local" | "staging" | "production" | string

export let env: Env | undefined

const _auth: { "apiKey": string | null,"roles": string | null } = { "apiKey": null, "roles": null }

export function setAuth(securitySchemaName: keyof typeof _auth, value: string | null): void {
  if (typeof _auth[securitySchemaName] === "undefined") {
    throw new Error(`Invalid security schema name: ${securitySchemaName}`)
  }
  _auth[securitySchemaName] = value
}

export type HandledResponses = { [status: string]: { code: string[] | null } }

const _throwOnUnexpectedResponse = (handledResponses: HandledResponses, response: AxiosResponse): void => {
  const handledResponsesForStatus = handledResponses[response.status]
  if (handledResponsesForStatus) {
    const handledResponseCodes = handledResponsesForStatus.code
    if (Array.isArray(handledResponseCodes)) {
      if (!handledResponseCodes.includes(response.data.code)) {
        throw new ResponseError({
          message: `Unexpected response code: ${response.data.code}`,
          code: "UNEXPECTED_RESPONSE",
          response
        })
      }
    }
  } else {
    throw new ResponseError({
      message: `Unexpected response status code: ${response.status}`,
      code: "UNEXPECTED_RESPONSE",
      response
    })
  }
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _getAuth(keys: Set<string>): { headers: { [key: string]: string }, params: URLSearchParams, withCredentials: boolean } {
  const headers: { [key: string]: string } = {}
  const params = new URLSearchParams()
  if (keys.has("apiKey") && _auth["apiKey"]) {
    headers["x-api-key"] = _auth["apiKey"]
  }
  if (keys.has("roles") && _auth["roles"]) {
      headers.Authorization = `Bearer ${_auth["roles"]}`
    }
  return { headers, params, withCredentials: true }
}

export class ResponseError<T> extends Error {
  code: string
  response: T

  constructor({ message, code, response }: { message: string, code: string, response: T }) {
    super(message)
    this.code = code
    this.response = response
  }
}

export const serverUrls: { [env in Env]: string } = {
  "local": "http://localhost:8000",
  "staging": "https://api.staging.notes.soluzionifutura.it",
  "production": "https://api.notes.soluzionifutura.it"
}

function _getFnUrl(endpoint: string, options?: { path?: { [key: string]: any }, params?: { [key: string]: any } }): string {
  const baseUrl = serverUrls[env!.toLowerCase()]
  if (!baseUrl) {
    throw new Error(`Invalid env: ${env}`)
  }

  if (options?.path) {
    Object.entries(options.path).forEach(([key, value]) => {
      endpoint = endpoint.replace(`{${key}}`, String(value))
    })
  }

  endpoint = endpoint.replace(/{.*?}/g, "")

  const url = new URL(baseUrl.replace(/\/$/, "") + "/" + endpoint.replace(/^\//, ""))
  if (options?.params) {
    Object.entries(options.params).forEach(([key, value]) => {
      url.searchParams.set(key, typeof value === "object" ? JSON.stringify(value) : value)
    })
  }

  return url.toString()
}

export function setup(params: {
  axios: AxiosStatic | AxiosInstance
  env: Env
  customServerUrls?: { [env: string]: string }
}): void {
  axios = params.axios
  env = params.env
  if (params.customServerUrls) {
    Object.assign(serverUrls, params.customServerUrls)
  }
  if (!serverUrls[env]) {
    throw new Error(`Missing server url for env: ${env}`)
  }
}

const _checkSetup = (): void => {
  if (!axios) {
    throw new Error("axios is not defined. Please run the sdk.setup() function or set axios instance to the sdk.")
  }
  if (!env) {
    throw new Error("env is not defined. Please run the sdk.setup() function or set env to the sdk.")
  }
}

/**
Say hello
*/
export type AxiosSayHelloSuccessResponse = (AxiosResponse<SayHello200ResponseSchema> & { status: 200 })
export type AxiosSayHelloErrorResponse = ((AxiosResponse<SayHello400ResponseSchema> & { status: 400 }) | (AxiosResponse<SayHello405ResponseSchema> & { status: 405 }) | (AxiosResponse<SayHello429ResponseSchema> & { status: 429 }) | (AxiosResponse<SayHello500ResponseSchema> & { status: 500 })) & { path: "/v1/hello/sayHello" }
export type AxiosSayHelloResponse = AxiosSayHelloSuccessResponse | AxiosSayHelloErrorResponse
export async function sayHello(data: SayHelloRequestSchema, config?: AxiosRequestConfig): Promise<AxiosSayHelloResponse> {
  _checkSetup()
  const securityParams: AxiosRequestConfig = {}
  const handledResponses = {
    "200": {
      "code": null
    },
    "400": {
      "code": [
        "VALIDATION_ERROR"
      ]
    },
    "405": {
      "code": [
        "METHOD_NOT_ALLOWED"
      ]
    },
    "429": {
      "code": [
        "THROTTLING"
      ]
    },
    "500": {
      "code": [
        "UNEXPECTED_ERROR"
      ]
    }
  }
  try {
    const res = await axios!.post(_getFnUrl("/v1/hello/sayHello"), data, config ? deepmerge(securityParams, config, { isMergeableObject: isPlainObject }) : securityParams)
    _throwOnUnexpectedResponse(handledResponses, res)
    return res as AxiosSayHelloSuccessResponse
  } catch (e) {
    const { response: res } = e as AxiosError
    if (res) {
      _throwOnUnexpectedResponse(handledResponses, res)
      return res as AxiosSayHelloErrorResponse
    } else {
      throw e
    }
  }
}

export type Any =
  | string
  | boolean
  | number
  | {
      [k: string]: unknown
    }
  | string[]
  | number[]
  | {
      [k: string]: unknown
    }[]
  | null

export type ValidationErrorResponseSchema = {
  message: string
  code: "VALIDATION_ERROR"
  details?: Any
  stack?: string
  [k: string]: unknown
}

export type MethodNotAllowedErrorResponseSchema = {
  message: string
  code: "METHOD_NOT_ALLOWED"
  details?: Any
  stack?: string
  [k: string]: unknown
}

export type ForbiddenErrorResponseSchema = {
  message: string
  code: "FORBIDDEN"
  details?: Any
  stack?: string
  [k: string]: unknown
}

export type UnauthorizedErrorResponseSchema = {
  message: string
  code: "UNAUTHORIZED"
  details?: Any
  stack?: string
  [k: string]: unknown
}

export type ThrottlingErrorResponseSchema = {
  message: string
  code: "THROTTLING"
  details?: Any
  stack?: string
  [k: string]: unknown
}

export type UnexpectedErrorResponseSchema = {
  message: string
  code: "UNEXPECTED_ERROR"
  details?: Any
  stack?: string
  [k: string]: unknown
}

/**
 * timestamp
 */
export type Timestamp = number

export type NullableTimestamp = number | null

export type Email = string

export type Week = number

export type Year = number

export type Month = number

export type OkSchema = {
  data: {
    status: string
  }
}

/**
 * UUID
 */
export type Id = string

export type NullableId = string | null

export type SayHello200ResponseSchema = {
  data: string
}

export type SayHello400ResponseSchema = ValidationErrorResponseSchema

export type SayHello405ResponseSchema = MethodNotAllowedErrorResponseSchema

export type SayHello429ResponseSchema = ThrottlingErrorResponseSchema

export type SayHello500ResponseSchema = UnexpectedErrorResponseSchema

export type SayHelloRequestSchema = {
  name: string
}
